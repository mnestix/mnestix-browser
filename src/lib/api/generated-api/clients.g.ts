//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.17.0.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */

// ReSharper disable InconsistentNaming

export class AasListClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private readonly baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    private constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : (window as any);
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
    }

    static create(
        _baseUrl: string = '',
        http?: {
            fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
        },
    ): AasListClient {
        return new AasListClient(_baseUrl, http ?? window);
    }

    /**
     * Return a list of all AAS as entries
     */
    getAasListEntries(signal?: AbortSignal | undefined): Promise<AasListEntry[]> {
        let url_ = this.baseUrl + '/api/AasList';
        url_ = url_.replace(/[?&]$/, '');

        let options_: RequestInit = {
            method: 'GET',
            signal,
            headers: {
                Accept: 'application/json',
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAasListEntries(_response);
        });
    }

    protected processGetAasListEntries(response: Response): Promise<AasListEntry[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200) result200!.push(item);
                } else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<AasListEntry[]>(null as any);
    }
}

export class TemplateClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : (window as any);
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
    }

    static create(
        _baseUrl: string = '',
        http?: {
            fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
        },
    ): TemplateClient {
        return new TemplateClient(_baseUrl, http ?? window);
    }

    /**
     * ONLY FOR INTERNAL USAGE. BearerToken needed.
     Creates a new custom template in the custom templates AAS of the given submodel semantic id.
     * @param defaultSubmodel The default submodel as json string
     * @return The identifier of the new created submodel in the custom templates AAS.
     */
    createCustomSubmodel(defaultSubmodel: any, signal?: AbortSignal | undefined): Promise<string> {
        let url_ = this.baseUrl + '/api/Template/createCustomSubmodel';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(defaultSubmodel);

        let options_: RequestInit = {
            body: content_,
            method: 'POST',
            signal,
            headers: {
                'Content-Type': 'application/json',
                Accept: 'application/json',
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCustomSubmodel(_response);
        });
    }

    protected processCreateCustomSubmodel(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException('A server side error occurred.', status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * ONLY FOR INTERNAL USAGE. BearerToken needed.
     Updates a custom template in the custom templates AAS.
     * @param customSubmodel The submodel to update as json string
     * @param submodelId The id of the submodel
     */
    updateCustomSubmodel(customSubmodel: any, submodelId: string, signal?: AbortSignal | undefined): Promise<void> {
        let url_ = this.baseUrl + '/api/Template/updateCustomSubmodel/{submodelId}';
        if (submodelId === undefined || submodelId === null)
            throw new Error("The parameter 'submodelId' must be defined.");
        url_ = url_.replace('{submodelId}', encodeURIComponent('' + submodelId));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(customSubmodel);

        let options_: RequestInit = {
            body: content_,
            method: 'POST',
            signal,
            headers: {
                'Content-Type': 'application/json',
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCustomSubmodel(_response);
        });
    }

    protected processUpdateCustomSubmodel(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 204) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException('A server side error occurred.', status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any };

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property)) this[property] = _data[property];
            }
            this.type = _data['type'];
            this.title = _data['title'];
            this.status = _data['status'];
            this.detail = _data['detail'];
            this.instance = _data['instance'];
            if (_data['extensions']) {
                this.extensions = {} as any;
                for (let key in _data['extensions']) {
                    if (_data['extensions'].hasOwnProperty(key))
                        (<any>this.extensions)![key] = _data['extensions'][key];
                }
            }
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any };

    [key: string]: any;
}

export class AasListEntry implements IAasListEntry {
    thumbnailUrl?: string | undefined;
    aasId?: string | undefined;
    assetId?: string | undefined;
    manufacturerProductDesignation?: { [key: string]: string } | undefined;
    manufacturerName?: { [key: string]: string } | undefined;
    productGroup?: string | undefined;

    constructor(data?: IAasListEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.thumbnailUrl = _data['thumbnailUrl'];
            this.aasId = _data['aasId'];
            this.assetId = _data['assetId'];
            if (_data['manufacturerProductDesignation']) {
                this.manufacturerProductDesignation = {} as any;
                for (let key in _data['manufacturerProductDesignation']) {
                    if (_data['manufacturerProductDesignation'].hasOwnProperty(key))
                        (<any>this.manufacturerProductDesignation)![key] = _data['manufacturerProductDesignation'][key];
                }
            }
            if (_data['manufacturerName']) {
                this.manufacturerName = {} as any;
                for (let key in _data['manufacturerName']) {
                    if (_data['manufacturerName'].hasOwnProperty(key))
                        (<any>this.manufacturerName)![key] = _data['manufacturerName'][key];
                }
            }
            this.productGroup = _data['productGroup'];
        }
    }
}

export interface IAasListEntry {
    thumbnailUrl?: string | undefined;
    aasId?: string | undefined;
    assetId?: string | undefined;
    manufacturerProductDesignation?: { [key: string]: string } | undefined;
    manufacturerName?: { [key: string]: string } | undefined;
    productGroup?: string | undefined;
}

export interface IAas {
    aasId?: string;
    assetIdShort?: string | undefined;
}

export interface IAddDataToAasResponse {
    results?: AasDataSupplyResult[];
}

export class AasDataSupplyResult implements IAasDataSupplyResult {
    templateId?: string;
    success?: boolean;
    message?: string;
    generatedSubmodelId?: string;

    constructor(data?: IAasDataSupplyResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.templateId = _data['templateId'];
            this.success = _data['success'];
            this.message = _data['message'];
            this.generatedSubmodelId = _data['generatedSubmodelId'];
        }
    }
}

export interface IAasDataSupplyResult {
    templateId?: string;
    success?: boolean;
    message?: string;
    generatedSubmodelId?: string;
}

export interface IAddDataToAasRequest {
    language: string;
    data: any;
    customTemplateIds: string[];
}

export interface IAasIds {
    assetId?: string;
    assetIdShort?: string;
    aasId?: string;
    aasIdShort?: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;
}

function throwException(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result?: any,
): any {
    if (result !== null && result !== undefined) throw result;
    else throw new ApiException(message, status, response, headers, null);
}
